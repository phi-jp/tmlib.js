<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
 * three.js
 */

tm.three = tm.three || {};


(function() {

    if (!tm.global.THREE) return ;

<span id='THREE-Texture'>    /**
</span>     * @class THREE.Texture
<span id='THREE-Scene'>     * Three.js ライブラリ内クラス
</span>     */
    /**
     * @class THREE.Scene
<span id='THREE-Mesh'>     * Three.js ライブラリ内クラス
</span>     */
    /**
     * @class THREE.Mesh
<span id='THREE-Object3D'>     * Three.js ライブラリ内クラス
</span>     */
    /**
<span id='tm-three-ThreeApp'>     * @class THREE.Object3D
</span>     * Three.js ライブラリ内クラス
     */
    
    /**
     * @class tm.three.ThreeApp
     * 3Dライブラリ - Three.jsをtmlib.jsで対応
     * @extends tm.app.BaseApp
     */
    tm.three.ThreeApp = tm.createClass({

        superClass: tm.app.BaseApp,
        
        canvas      : null,
<span id='tm-three-ThreeApp-method-constructor'>        background  : null,
</span>        
        _scenes      : null,
        _sceneIndex  : 0,
        
        /**
         * @constructor
         * コンストラクタ
         */
        init: function(canvas) {
            if (canvas instanceof HTMLCanvasElement) {
                this.element = canvas;
            }
            else if (typeof canvas == &quot;string&quot;) {
                this.element = document.querySelector(canvas);
            }
            else {
                this.element = document.createElement(&quot;canvas&quot;);
                document.body.appendChild(this.element);
            }

            // 親の初期化
            this.superInit(this.element);

            // レンダラーを生成
//            this.renderer = new THREE.CanvasRenderer({ canvas: this.element });
            this.renderer = new THREE.WebGLRenderer({ canvas: this.element, clearColor: 0x222222, clearAlpha: 1.0 });

<span id='tm-three-ThreeApp-property-resize'>            this.renderer.setSize(this.element.width, this.element.height);
</span>            
            // シーン周り
            this._scenes = [ tm.three.Scene() ];
        },
        
        /**
         * @property
         * @TODO ?
         */
        resize: function(width, height) {
            this.width = width;
<span id='tm-three-ThreeApp-property-resizeWindow'>            this.height= height;
</span>            this.renderer.setSize(this.width, this.height);
            
            return this;
        },

        /**
         * @property
         * @TODO ?
         */
        resizeWindow: function() {
            this.width = innerWidth;
<span id='tm-three-ThreeApp-property-fitWindow'>            this.height= innerHeight;
</span>            this.renderer.setSize(this.width, this.height);
            
            return this;
        },
        
        /**
         * @property
         * 画面にフィットさせる
         */
        fitWindow: function(everFlag) {
            // 画面にフィット
            var _fitFunc = function() {
                everFlag = everFlag === undefined ? true : everFlag;
                var e = this.element;
                var s = e.style;
                
                s.position = &quot;absolute&quot;;
                s.left = &quot;0px&quot;;
                s.top  = &quot;0px&quot;;
                
                var rateWidth = e.width/window.innerWidth;
                var rateHeight= e.height/window.innerHeight;
                var rate = e.height/e.width;
                
                if (rateWidth &gt; rateHeight) {
                    s.width  = innerWidth+&quot;px&quot;;
                    s.height = innerWidth*rate+&quot;px&quot;;
                }
                else {
                    s.width  = innerHeight/rate+&quot;px&quot;;
                    s.height = innerHeight+&quot;px&quot;;
                }
            }.bind(this);
            
            // 一度実行しておく
            _fitFunc();
            // リサイズ時のリスナとして登録しておく
            if (everFlag) {
<span id='tm-three-ThreeApp-property-_draw'>                window.addEventListener(&quot;resize&quot;, _fitFunc, false);
</span>            }
            
            // マウスとタッチの座標更新関数をパワーアップ
            this.mouse._mousemove = this.mouse._mousemoveScale;
            this.touch._touchmove = this.touch._touchmoveScale;
        },

        /**
         * @property
         * @TODO ?
         * @private
<span id='tm-three-ThreeApp-property-width'>         */
</span>        _draw: function() {
            // 描画は全てのシーン行う
            for (var i=0, len=this._scenes.length; i&lt;len; ++i) {
<span id='tm-three-ThreeApp-property-height'>                this.renderer.render(this.currentScene, this.currentScene.camera);
</span>            }
        },
        
    });
    
    
    /**
     * @property    width
     * 幅
     */
    tm.three.ThreeApp.prototype.accessor(&quot;width&quot;, {
        &quot;get&quot;: function()   { return this.element.width; },
        &quot;set&quot;: function(v)  { this.element.width = v; }
    });
    
    /**
<span id='tm-three-Element'>     * @property    height
</span>     * 高さ
     */
    tm.three.ThreeApp.prototype.accessor(&quot;height&quot;, {
        &quot;get&quot;: function()   { return this.element.height; },
<span id='tm-three-Element-method-constructor'>        &quot;set&quot;: function(v)  { this.element.height = v; }
</span>    });
    
})();


(function() {
    
    if (!tm.global.THREE) return ;

    /**
     * @class tm.three.Element
     * @TODO ?
     * @extends THREE.Object3D
     */
    tm.three.Element = tm.createClass({

<span id='tm-three-Element-property-update'>        superClass: THREE.Object3D,
</span>
        /**
         * @constructor
<span id='tm-three-Element-property-_update'>         * コンストラクタ
</span>         */
        init: function() {
            // THREE.Object3D の初期化 
            THREE.Object3D.call(this);

            tm.event.EventDispatcher.prototype.init.call(this);
        },
        
        /**
         * @property
         * 更新処理
         */
        update: function() {},

        /**
         * @property
         * @TODO ?
         * @private
         */
        _update: function(app) {
            // 更新有効チェック
            if (this.isUpdate == false) return ;
            
            this.update(app);
            
            var e = tm.event.Event(&quot;enterframe&quot;);
            e.app = app;
            this.dispatchEvent(e);
            // 子供達も実行
            if (this.children.length &gt; 0) {
                var tempChildren = this.children.slice();
                for (var i=0,len=tempChildren.length; i&lt;len; ++i) {
                    var child = tempChildren[i];
<span id='tm-three-MeshElement'>                    child._update &amp;&amp; child._update(app);
</span>                }
                //this.execChildren(arguments.callee, app);
            }
        },
    });
    
<span id='tm-three-MeshElement-method-constructor'>    // tm.event.EventDispatcher を継承
</span>    tm.three.Element.prototype.$safe(tm.event.EventDispatcher.prototype);
    
})();

(function() {
    
    if (!tm.global.THREE) return ;

    /**
     * @class tm.three.MeshElement
     * @TODO ?
     * @extends THREE.Mesh
     */
    tm.three.MeshElement = tm.createClass({
        
        superClass: THREE.Mesh,
        
        /**
         * @constructor
         * コンストラクタ
         */
<span id='tm-three-CubeElement'>        init: function(geometry, material) {
</span>            material = material || new THREE.MeshNormalMaterial();
            // THREE.Mesh の初期化
            THREE.Mesh.call(this, geometry, material);

<span id='tm-three-CubeElement-method-constructor'>            tm.three.Element.prototype.init.call(this);
</span>        },
    });
    
    // tm.three.Element を継承
    tm.three.MeshElement.prototype.$safe(tm.three.Element.prototype);

    
    /**
     * @class tm.three.CubeElement
     * @TODO ?
     * @extends tm.three.MeshElement
     */
    tm.three.CubeElement = tm.createClass({
        superClass: tm.three.MeshElement,

        /**
         * @constructor
<span id='tm-three-SphereElement'>         * コンストラクタ
</span>         */
        init: function(width, height, depth) {
            width  = width || 100;
            height = height || 100;
            depth  = depth || 100;

<span id='tm-three-SphereElement-method-constructor'>            var geometry = new THREE.CubeGeometry(width, height, depth);
</span>            var material = new THREE.MeshNormalMaterial();

            this.superInit(geometry, material);
        }
    });


    /**
     * @class tm.three.SphereElement
     * @TODO ?
     * @extends tm.three.MeshElement
     */
    tm.three.SphereElement = tm.createClass({
        superClass: tm.three.MeshElement,

        /**
         * @constructor
         * コンストラクタ
         */
<span id='tm-three-PlaneElement'>        init: function(radius, widthSegments, heightSegments) {
</span>            radius          = radius || 45;
            widthSegments   = widthSegments || 16;
            heightSegments  = heightSegments || 12;

<span id='tm-three-PlaneElement-method-constructor'>            var geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
</span>            var material = new THREE.MeshNormalMaterial();

            this.superInit(geometry, material);
        }
    });

    /**
     * @class tm.three.PlaneElement
     * @TODO ?
<span id='tm-three-FloorElement'>     * @extends tm.three.MeshElement
</span>     */
    tm.three.PlaneElement = tm.createClass({
        superClass: tm.three.MeshElement,

        /**
         * @constructor
         * コンストラクタ
         */
<span id='tm-three-FloorElement-method-constructor'>        init: function(width, height) {
</span>            var geometry = new THREE.PlaneGeometry(width, height);
            var material = new THREE.MeshNormalMaterial();

            this.superInit(geometry, material);
        }
    });


    /**
     * @class tm.three.FloorElement
     * @TODO ?
     * @extends tm.three.MeshElement
     */
    tm.three.FloorElement = tm.createClass({
        superClass: tm.three.MeshElement,

        /**
<span id='tm-three-FloorElement-property-_render'>         * @constructor
</span>         * コンストラクタ
         */
        init: function(width, height) {
            width  = width || 1000;
            height = height || 1000;
            var geometry = new THREE.PlaneGeometry(width, height);
            var material = new THREE.MeshBasicMaterial();

            this.superInit(geometry, material);

            this.rotation.x = -Math.PI/2;
            this._render();
        },

        /**
         * @property
         * @TODO ?
         * @private
         */
        _render: function() {
            var c = tm.graphics.Canvas();
<span id='tm-three-TextElement'>            c.resize(128, 128);
</span>            c.clearColor(&quot;#444&quot;);
            c.setFillStyle(&quot;white&quot;);
            c.fillRect(0, 0, 64, 64);
            c.fillRect(64, 64, 64, 64);

<span id='tm-three-TextElement-method-constructor'>            var texture = new THREE.Texture(c.element);
</span>            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(10, 10);
            texture.needsUpdate = true;
            this.material.map = texture;
        }
    });

    /**
     * @class tm.three.TextElement
<span id='tm-three-CanvasTexture'>     * @TODO ?
</span>     * @extends tm.three.MeshElement
     */
    tm.three.TextElement = tm.createClass({
        superClass: tm.three.MeshElement,

        /**
         * @constructor
<span id='tm-three-CanvasTexture-method-constructor'>         * コンストラクタ
</span>         */
        init: function(text, param) {
            var geometry = new THREE.TextGeometry(text, param);
            var material = new THREE.MeshNormalMaterial();

            this.superInit(geometry, material);
        }
    });

    /**
     * @class tm.three.CanvasTexture
     * @TODO ?
<span id='tm-three-Scene'>     * @extends THREE.Texture
</span>     */
    tm.three.CanvasTexture = tm.createClass({
        superClass: THREE.Texture,

        canvas: null,

        /**
         * @constructor
<span id='tm-three-Scene-method-constructor'>         * コンストラクタ
</span>         */
        init: function() {
            this.canvas = tm.graphics.Canvas();

            THREE.Texture.call(this, this.canvas.element);
            this.needsUpdate = true;
        }

    });


})();

(function() {
    
    if (!tm.global.THREE) return ;

    /**
     * @class tm.three.Scene
     * シーン
     * @extends THREE.Scene
     */
    tm.three.Scene = tm.createClass({
        
        superClass: THREE.Scene,
        
        /**
         * @constructor
         * コンストラクタ
         */
<span id='tm-three-Scene-property-intersect'>        init: function(fov, aspect) {
</span>            fov = fov || 60;
            aspect = aspect || 640/480;
            // THREE.Scene の初期化
            THREE.Scene.call(this);

            // tm.three.Element を継承
            tm.three.Element.prototype.init.call(this);

            this.camera = new THREE.PerspectiveCamera(fov, aspect, 1, 10000);
            this.camera.position.y = 100;
            this.camera.position.z = 500;

            this.projector = new THREE.Projector();
        },

        /**
         * @property
         * @TODO ?
         */
        intersect: function(objects) {
            objects = objects || this.children;
            var mouseX = this.app.pointing.x;
            var mouseY = this.app.pointing.y;

            mouseX = (mouseX/this.app.width) *2-1;
            mouseY =-(mouseY/this.app.height)*2+1;

            var vector = new THREE.Vector3(mouseX, mouseY, 0.5);
            this.projector.unprojectVector(vector, this.camera);

            var raycaster = new THREE.Raycaster(
                this.camera.position, vector.sub(this.camera.position).normalize()
            );

            return raycaster.intersectObjects(objects);
        }
    });
    
    // tm.three.Element を継承
    tm.three.Scene.prototype.$safe(tm.three.Element.prototype);
})();




</pre>
</body>
</html>
