<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
 * canvas.js
 */

tm.graphics = tm.graphics || {};

(function() {
    
<span id='tm-graphics-Canvas'>    /**
</span>     * @class tm.graphics.Canvas
     * キャンバス
     */
    tm.graphics.Canvas = tm.createClass({
<span id='tm-graphics-Canvas-property-element'>        
</span>        /**
         * 要素
         */
        element: null,
<span id='tm-graphics-Canvas-property-canvas'>        
</span>        /**
         * キャンバス
         */
<span id='tm-graphics-Canvas-property-context'>        canvas: null,
</span>        
        /**
         * コンテキスト
         */
<span id='tm-graphics-Canvas-method-constructor'>        context: null,
</span>        
        /**
         * @constructor
         * 初期化
         */
        init: function(canvas) {
            this.canvas = null;
            if (typeof canvas == &quot;string&quot;) {
                this.canvas = document.querySelector(canvas);
            }
            else {
                this.canvas = canvas || document.createElement(&quot;canvas&quot;);
            }
            this.element            = this.canvas;
            this.context            = this.canvas.getContext(&quot;2d&quot;);
            this.context.lineCap    = &quot;round&quot;;
<span id='tm-graphics-Canvas-property-resize'>            this.context.lineJoin   = &quot;round&quot;;
</span>        },
        
        /**
         * @property
         * リサイズする
         */
        resize: function(width, height) {
            this.canvas.width   = width;
<span id='tm-graphics-Canvas-property-resizeWindow'>            this.canvas.height  = height;
</span>            return this;
        },
        
        /**
         * @property
         * リサイズウィンドウ
         */
        resizeWindow: function() {
            this.canvas.style.position  = &quot;fixed&quot;;
            this.canvas.style.margin    = &quot;0px&quot;;
            this.canvas.style.padding   = &quot;0px&quot;;
            this.canvas.style.left      = &quot;0px&quot;;
            this.canvas.style.top       = &quot;0px&quot;;
<span id='tm-graphics-Canvas-property-resizeToFitScreen'>            return this.resize(window.innerWidth, window.innerHeight);
</span>        },
        
        /**
         * @property
         * フィット
         */
        resizeToFitScreen: function() {
            this.canvas.style.position  = &quot;fixed&quot;;
            this.canvas.style.margin    = &quot;0px&quot;;
            this.canvas.style.padding   = &quot;0px&quot;;
            this.canvas.style.left      = &quot;0px&quot;;
            this.canvas.style.top       = &quot;0px&quot;;
<span id='tm-graphics-Canvas-property-fitWindow'>            return this.resize(window.innerWidth, window.innerHeight);
</span>        },
        
        /**
         * @property
         * 拡縮で画面にフィットさせる
         * 名前は仮. 検討する
         */
        fitWindow: function(everFlag) {
            var _fitFunc = function() {
                everFlag = everFlag === undefined ? true : everFlag;
                var e = this.element;
                var s = e.style;
                
                s.position = &quot;absolute&quot;;
                s.margin = &quot;auto&quot;;
                s.left = &quot;0px&quot;;
                s.top  = &quot;0px&quot;;
                s.bottom = &quot;0px&quot;;
                s.right = &quot;0px&quot;;

                var rateWidth = e.width/window.innerWidth;
                var rateHeight= e.height/window.innerHeight;
                var rate = e.height/e.width;
                
                if (rateWidth &gt; rateHeight) {
                    s.width  = innerWidth+&quot;px&quot;;
                    s.height = innerWidth*rate+&quot;px&quot;;
                }
                else {
                    s.width  = innerHeight/rate+&quot;px&quot;;
                    s.height = innerHeight+&quot;px&quot;;
                }
            }.bind(this);
            
            // 一度実行しておく
            _fitFunc();
<span id='tm-graphics-Canvas-property-clear'>            // リサイズ時のリスナとして登録しておく
</span>            if (everFlag) {
                window.addEventListener(&quot;resize&quot;, _fitFunc, false);
            }
        },
        
        /**
         * @property
         * クリア
         */
        clear: function(x, y, width, height) {
            x = x || 0;
            y = y || 0;
<span id='tm-graphics-Canvas-property-clearColor'>            width = width || this.width;
</span>            height= height|| this.height;
            this.context.clearRect(x, y, width, height);
            return this;
        },
        
        
        /**
         * @property
         * 色指定クリア
         * @param {String}  fillStyle
         * @param {Number}  [x=0]
         * @param {Number}  [y=0]
         * @param {Number}  [width=this.width]
         * @param {Number}  [height=this.height]
         */
        clearColor: function(fillStyle, x, y, width, height) {
            x = x || 0;
            y = y || 0;
            width = width || this.width;
            height= height|| this.height;
            
            this.save();
            this.resetTransform();          // 行列初期化
<span id='tm-graphics-Canvas-property-beginPath'>            this.fillStyle = fillStyle;     // 塗りつぶしスタイルセット
</span>            this.context.fillRect(x, y, width, height);
            this.restore();
            
            return this;
<span id='tm-graphics-Canvas-property-closePath'>        },
</span>                
        /**
         * @property
         * パスを開始(リセット)
         */
        beginPath: function() {
<span id='tm-graphics-Canvas-property-moveTo'>            this.context.beginPath();
</span>            return this;
        },
                
        /**
         * @property
         *  パスを閉じる
         */
        closePath: function() {
<span id='tm-graphics-Canvas-property-lineTo'>            this.context.closePath();
</span>            return this;
        },
        

        /**
         * @property
         *  新規パス生成
         */
        moveTo: function(x, y) {
<span id='tm-graphics-Canvas-property-fill'>            this.context.moveTo(x, y);
</span>            return this;
        },
        
        /**
         * @property
         * パスに追加
         */
<span id='tm-graphics-Canvas-property-stroke'>        lineTo: function(x, y) {
</span>            this.context.lineTo(x, y);
            return this;
        },
        
        /**
         * @property
         * パス内を塗りつぶす
<span id='tm-graphics-Canvas-property-clip'>         */
</span>        fill: function() {
            this.context.fill();
            return this;
        },
        
        /**
         * @property
<span id='tm-graphics-Canvas-property-drawPoint'>         * パス上にラインを引く
</span>         */
        stroke: function() {
            this.context.stroke();
            return this;
        },
        
        /**
         * @property
         * クリップ
         */
        clip: function() {
<span id='tm-graphics-Canvas-property-line'>            this.context.clip();
</span>            return this;
        },
        
        /**
         * @property
         * 点描画
         */
        drawPoint: function(x, y) {
<span id='tm-graphics-Canvas-property-drawLine'>            return this.strokeRect(x, y, 1, 1);
</span>            // return this.beginPath().moveTo(x-0.5, y-0.5).lineTo(x+0.5, y+0.5).stroke();
        },

        /**
         * @property
<span id='tm-graphics-Canvas-property-drawDashLine'>         * ラインパスを作成
</span>         */
        line: function(x0, y0, x1, y1) {
            return this.moveTo(x0, y0).lineTo(x1, y1);
        },
        
        /**
         * @property
         * ラインを描画
         */
        drawLine: function(x0, y0, x1, y1) {
            return this.beginPath().line(x0, y0, x1, y1).stroke();
        },
        
        /**
         * @property
         * ダッシュラインを描画
         */
        drawDashLine: function(x0, y0, x1, y1, pattern) {
            var patternTable = null;
            if (typeof(pattern) == &quot;string&quot;) {
                patternTable = pattern;
            }
            else {
                pattern = pattern || 0xf0f0;
                patternTable = pattern.toString(2);
            }
            patternTable = patternTable.padding(16, '1');
            
            var vx = x1-x0;
            var vy = y1-y0;
            var len = Math.sqrt(vx*vx + vy*vy);
            vx/=len; vy/=len;
            
            var x = x0;
<span id='tm-graphics-Canvas-property-drawArrow'>            var y = y0;
</span>            for (var i=0; i&lt;len; ++i) {
                if (patternTable[i%16] == '1') {
                    this.drawPoint(x, y);
                    // this.fillRect(x, y, this.context.lineWidth, this.context.lineWidth);
                }
                x += vx;
                y += vy;
            }
            
            return this;
        },
        
        /**
         * @property
         * v0(x0, y0), v1(x1, y1) から角度を求めて矢印を描画
<span id='tm-graphics-Canvas-property-lines'>         * http://hakuhin.jp/as/rotation.html
</span>         */
        drawArrow: function(x0, y0, x1, y1, arrowRadius) {
            var vx = x1-x0;
            var vy = y1-y0;
            var angle = Math.atan2(vy, vx)*180/Math.PI;
            
            this.drawLine(x0, y0, x1, y1);
<span id='tm-graphics-Canvas-property-strokeLines'>            this.fillPolygon(x1, y1, arrowRadius || 5, 3, angle);
</span>            
            return this;
        },
        
        
        /**
         * @property
         * lines
         */
        lines: function() {
            this.moveTo(arguments[0], arguments[1]);
<span id='tm-graphics-Canvas-property-fillLines'>            for (var i=1,len=arguments.length/2; i&lt;len; ++i) {
</span>                this.lineTo(arguments[i*2], arguments[i*2+1]);
            }
            return this;
        },

        /**
         * @property
         * @TODO ?
         */
<span id='tm-graphics-Canvas-property-rect'>        strokeLines: function() {
</span>            this.beginPath();
            this.lines.apply(this, arguments);
            this.stroke();
            return this;
        },

        /**
         * @property
         * @TODO ?
         */
<span id='tm-graphics-Canvas-property-fillRect'>        fillLines: function() {
</span>            this.beginPath();
            this.lines.apply(this, arguments);
            this.fill();
            return this;
        },
        
        /**
         * @property
<span id='tm-graphics-Canvas-property-strokeRect'>         * 四角形パスを作成する
</span>         */
        rect: function(x, y, width, height) {
            this.context.rect.apply(this.context, arguments);
            return this;
        },
        
<span id='tm-graphics-Canvas-property-roundRect'>        /**
</span>         * @property
         * 四角形塗りつぶし描画
         */
        fillRect: function() {
            this.context.fillRect.apply(this.context, arguments);
            return this;
        },
        
        /**
         * @property
         * 四角形ライン描画
         */
        strokeRect: function() {
            this.context.strokeRect.apply(this.context, arguments);
            return this;
        },
        
        /**
         * @property
         * 角丸四角形パス
         */
        roundRect: function(x, y, width, height, radius) {
            var l = x + radius;
            var r = x + width - radius;
            var t = y + radius;
            var b = y + height - radius;
            
            /*
            var ctx = this.context;
            ctx.moveTo(l, y);
            ctx.lineTo(r, y);
            ctx.quadraticCurveTo(x+width, y, x+width, t);
            ctx.lineTo(x+width, b);
            ctx.quadraticCurveTo(x+width, y+height, r, y+height);
            ctx.lineTo(l, y+height);
            ctx.quadraticCurveTo(x, y+height, x, b);
            ctx.lineTo(x, t);
<span id='tm-graphics-Canvas-property-fillRoundRect'>            ctx.quadraticCurveTo(x, y, l, y);
</span>            /**/
            
            this.context.arc(l, t, radius,     -Math.PI, -Math.PI*0.5, false);  // 左上
            this.context.arc(r, t, radius, -Math.PI*0.5,            0, false);  // 右上
<span id='tm-graphics-Canvas-property-strokeRoundRect'>            this.context.arc(r, b, radius,            0,  Math.PI*0.5, false);  // 右下
</span>            this.context.arc(l, b, radius,  Math.PI*0.5,      Math.PI, false);  // 左下
            this.closePath();
            
<span id='tm-graphics-Canvas-property-polygon'>            return this;
</span>        },
        /**
         * @property
         * 角丸四角形塗りつぶし
         */
        fillRoundRect: function(x, y, width, height, radius) {
            return this.beginPath().roundRect(x, y, width, height, radius).fill();
        },
        /**
         * @property
         * 角丸四角形ストローク描画
         */
        strokeRoundRect: function(x, y, width, height, radius) {
            return this.beginPath().roundRect(x, y, width, height, radius).stroke();
        },
        
        /**
         * @property
         * ポリゴンパス
         */
        polygon: function(x, y, size, sides, offsetAngle) {
<span id='tm-graphics-Canvas-property-fillPolygon'>            var radDiv = (Math.PI*2)/sides;
</span>            var radOffset = (offsetAngle!=undefined) ? offsetAngle*Math.PI/180 : -Math.PI/2;
            
<span id='tm-graphics-Canvas-property-strokePolygon'>            this.moveTo(x + Math.cos(radOffset)*size, y + Math.sin(radOffset)*size);
</span>            for (var i=1; i&lt;sides; ++i) {
                var rad = radDiv*i+radOffset;
                this.lineTo(
                    x + Math.cos(rad)*size,
                    y + Math.sin(rad)*size
                );
            }
<span id='tm-graphics-Canvas-property-star'>            this.closePath();
</span>            return this;
        },
        /**
         * @property
         * ポリゴン塗りつぶし
         */
        fillPolygon: function(x, y, radius, sides, offsetAngle) {
            return this.beginPath().polygon(x, y, radius, sides, offsetAngle).fill();
        },
        /**
         * @property
         * ポリゴンストローク描画
         */
        strokePolygon: function(x, y, radius, sides, offsetAngle) {
            return this.beginPath().polygon(x, y, radius, sides, offsetAngle).stroke();
        },
        
        /**
         * @property
         * star
         */
        star: function(x, y, radius, sides, sideIndent, offsetAngle) {
            var sideIndentRadius = radius * (sideIndent || 0.38);
<span id='tm-graphics-Canvas-property-fillStar'>            var radOffset = (offsetAngle) ? offsetAngle*Math.PI/180 : -Math.PI/2;
</span>            var radDiv = (Math.PI*2)/sides/2;
            
            this.moveTo(
                x + Math.cos(radOffset)*radius,
                y + Math.sin(radOffset)*radius
            );
<span id='tm-graphics-Canvas-property-strokeStar'>            for (var i=1; i&lt;sides*2; ++i) {
</span>                var rad = radDiv*i + radOffset;
                var len = (i%2) ? sideIndentRadius : radius;
                this.lineTo(
                    x + Math.cos(rad)*len,
                    y + Math.sin(rad)*len
                );
            }
            this.closePath();
            return this;
        },

        /**
         * @property
         * @TODO ?
         */
        fillStar: function(x, y, radius, sides, sideIndent, offsetAngle) {
            return this.beginPath().star(x, y, radius, sides, sideIndent, offsetAngle).fill();
        },

        /**
         * @property
         * @TODO ?
         */
        strokeStar: function(x, y, radius, sides, sideIndent, offsetAngle) {
            return this.beginPath().star(x, y, radius, sides, sideIndent, offsetAngle).stroke();
        },

        /*
         * @property
         * heart
         */
        heart: function(x, y, radius, angle) {
            var half_radius = radius*0.5;
            var rad = (angle === undefined) ? Math.PI/4 : Math.degToRad(angle);

            // 半径 half_radius の角度 angle 上の点との接線を求める
            var p = Math.cos(rad)*half_radius;
            var q = Math.sin(rad)*half_radius;

            // 円の接線の方程式 px + qy = r^2 より y = (r^2-px)/q
            var x2 = -half_radius;
            var y2 = (half_radius*half_radius-p*x2)/q;

            // 中心位置調整
            var height = y2 + half_radius;
            var offsetY = half_radius-height/2;

            // パスをセット
<span id='tm-graphics-Canvas-property-circle'>            this.moveTo(0+x, y2+y+offsetY);
</span>
            this.arc(-half_radius+x, 0+y+offsetY, half_radius, Math.PI-rad, Math.PI*2);
            this.arc(half_radius+x, 0+y+offsetY, half_radius, Math.PI, rad);
            this.closePath();

<span id='tm-graphics-Canvas-property-fillCircle'>            return this;
</span>        },

        /*
         * @property
         * fill heart
         */
        fillHeart: function(x, y, radius, angle) {
            return this.beginPath().heart(x, y, radius, angle).fill();
        },

        /*
         * @property
         * stroke heart
         */
        strokeHeart: function(x, y, radius, angle) {
<span id='tm-graphics-Canvas-property-strokeCircle'>            return this.beginPath().heart(x, y, radius, angle).stroke();
</span>        },
        
        /**
         * @property
         * 円のパスを設定
         */
        circle: function(x, y, radius) {
<span id='tm-graphics-Canvas-property-arc'>            this.context.arc(x, y, radius, 0, Math.PI*2, false);
</span>            return this;
        },
        
        /**
         * @property
         * 塗りつぶし円を描画
         */
        fillCircle: function(x, y, radius) {
            var c = this.context;
            c.beginPath();
<span id='tm-graphics-Canvas-property-fillArc'>            c.arc(x, y, radius, 0, Math.PI*2, false);
</span>            c.closePath();
            c.fill();
            return this;
            // return this.beginPath().circle(x, y, radius).fill();
        },
        
        /**
         * @property
<span id='tm-graphics-Canvas-property-strokeArc'>         * ストローク円を描画
</span>         */
        strokeCircle: function(x, y, radius) {
            return this.beginPath().circle(x, y, radius).stroke();
        },
        
        
        /**
         * @property
         * 円弧のパスを設定
         */
<span id='tm-graphics-Canvas-property-triangle'>        arc: function(x, y, radius, startAngle, endAngle, anticlockwise) {
</span>            this.context.arc(x, y, radius, startAngle, endAngle, anticlockwise);
            return this;
        },
        
        /**
         * @property
<span id='tm-graphics-Canvas-property-fillTriangle'>         * 塗りつぶし円弧を描画
</span>         */
        fillArc: function(x, y, radius, startAngle, endAngle, anticlockwise) {
            return this.beginPath().arc(x, y, radius, startAngle, endAngle, anticlockwise).fill();
        },
        
<span id='tm-graphics-Canvas-property-strokeTriangle'>        /**
</span>         * @property
         * ストローク円弧を描画
         */
        strokeArc: function(x, y, radius, startAngle, endAngle, anticlockwise) {
<span id='tm-graphics-Canvas-property-fillText'>            return this.beginPath().arc(x, y, radius, startAngle, endAngle, anticlockwise).stroke();
</span>        },
        
        /**
         * @property
         * 三角形パスを設定
         */
        triangle: function(x0, y0, x1, y1, x2, y2) {
<span id='tm-graphics-Canvas-property-strokeText'>            this.moveTo(x0, y0).lineTo(x1, y1).lineTo(x2, y2);
</span>            this.closePath();
            return this;
        },
        
        /**
         * @property
         * 塗りつぶし三角形を描画
<span id='tm-graphics-Canvas-property-fillTextList'>         */
</span>        fillTriangle: function(x0, y0, x1, y1, x2, y2) {
            return this.beginPath().triangle(x0, y0, x1, y1, x2, y2).fill();
        },
        
        /**
         * @property
         * ストローク三角形を描画
         */
        strokeTriangle: function(x0, y0, x1, y1, x2, y2) {
            return this.beginPath().triangle(x0, y0, x1, y1, x2, y2).stroke();
        },
        

<span id='tm-graphics-Canvas-property-strokeTextList'>        /**
</span>         * @property
         * 塗りつぶしテキストを描画
         */
        fillText: function(text, x, y) {
            return this.context.fillText.apply(this.context, arguments);
        },
        
        /**
         * @property
         * ストロークテキスト
         */
        strokeText: function(text, x, y) {
            return this.context.strokeText.apply(this.context, arguments);
        },
        
<span id='tm-graphics-Canvas-property-drawImage'>        /**
</span>         * @property
         * 塗りつぶしテキスト
         */
        fillTextList: function(text_list, x, y, offsetX, offsetY) {
            offsetX = offsetX || 0;
            offsetY = offsetY || 20;
            
            for (var i=0,len=text_list.length; i&lt;len; ++i) {
                this.fillText(text_list[i], x+offsetX*i, y+offsetY*i);
            }
            
            return this;
        },
        
        /**
         * @property
<span id='tm-graphics-Canvas-property-drawTexture'>         * ストロークテキストリスト
</span>         */
        strokeTextList: function(text_list, x, y, offsetX, offsetY) {
            offsetX = offsetX || 0;
            offsetY = offsetY || 20;
            
            for (var i=0,len=text_list.length; i&lt;len; ++i) {
<span id='tm-graphics-Canvas-property-drawBitmap'>                this.strokeText(x+offsetX*i, y+offsetY*i, text_list[i]);
</span>            }
            
            return this;
        },
                
        /**
         * @property
         * 画像描画
         */
        drawImage: function(image, x, y) {
<span id='tm-graphics-Canvas-property-setTransform'>            this.context.drawImage.apply(this.context, arguments);
</span>            return ;
            
            x = x || 0;
            y = y || 0;
            this.context.drawImage(image, x, y);
            return this;
            // ctx.drawImage(this.image.canvas,
<span id='tm-graphics-Canvas-property-resetTransform'>                // 0, 0, this.width, this.height,
</span>                // -this.width/2, -this.height/2, this.width, this.height);
        },
        
        /**
         * @property
         * テクスチャ描画
         */
<span id='tm-graphics-Canvas-property-setTransformCenter'>        drawTexture: function(texture, x, y) {
</span>            arguments[0] = texture.element;
            this.context.drawImage.apply(this.context, arguments);
            
            return ;
        },
        
        /**
         * @property
<span id='tm-graphics-Canvas-property-transform'>         * ビットマップ描画
</span>         */
        drawBitmap: function(bitmap, x, y) {
            arguments[0] = bitmap.imageData;
            this.context.putImageData.apply(this.context, arguments);
            
<span id='tm-graphics-Canvas-property-save'>            return ;
</span>        },
        
        /**
         * @property
         * 行列をセット
         */
        setTransform: function(m11, m12, m21, m22, dx, dy) {
<span id='tm-graphics-Canvas-property-restore'>            this.context.setTransform(m11, m12, m21, m22, dx, dy);
</span>            return this;
        },
        
        
        /**
         * @property
<span id='tm-graphics-Canvas-property-translate'>         * 行列をリセット
</span>         */
        resetTransform: function() {
            this.setTransform(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
            return this;
        },
        
        
<span id='tm-graphics-Canvas-property-rotate'>        /**
</span>         * @property
         * 中心に移動
         */
        setTransformCenter: function() {
<span id='tm-graphics-Canvas-property-scale'>            this.context.setTransform(1, 0, 0, 1, this.width/2, this.height/2);
</span>            return this;
        },
        
        /**
         * @property
         * 行列を掛ける
         */
        transform: function(m11, m12, m21, m22, dx, dy) {
<span id='tm-graphics-Canvas-property-saveAsImage'>            this.context.transform(m11, m12, m21, m22, dx, dy);
</span>            return this;
        },
        
        /**
         * @property
         * 保存
         */
        save: function() {
            this.context.save();
            return this;
        },
        
        /**
         * @property
         * 復元
         */
        restore: function() {
            this.context.restore();
            return this;
        },
        
        /**
         * @property
<span id='tm-graphics-Canvas-property-setCompositing'>         * 移動
</span>         */
        translate: function(x, y) {
            this.context.translate(x, y);
            return this;
        },
        
<span id='tm-graphics-Canvas-property-setFillStyle'>        /**
</span>         * @property
         * 回転
         */
        rotate: function(rotation) {
            this.context.rotate(rotation);
            return this;
        },
        
<span id='tm-graphics-Canvas-property-setStrokeStyle'>        /**
</span>         * @property
         * スケール
         */
        scale: function(scaleX, scaleY) {
            this.context.scale(scaleX, scaleY);
            return this;
        },
<span id='tm-graphics-Canvas-property-setColorStyle'>        
</span>        /**
         * @property
         * 画像として保存
         */
        saveAsImage: function(mime_type) {
            mime_type = mime_type || tm.graphics.Canvas.MIME_TYPE_PNG;
            var data_url = this.canvas.toDataURL(mime_type);
            // data_url = data_url.replace(mime_type, &quot;image/octet-stream&quot;);
            window.open(data_url, &quot;save&quot;);
            
<span id='tm-graphics-Canvas-property-setText'>            // toDataURL を使えば下記のようなツールが作れるかも!!
</span>            // TODO: プログラムで絵をかいて保存できるツール
        },

        /**
         * @property
         * @TODO ?
         */
        setCompositing: function(alpha, compositeOperation) {
            // TODO
        },

<span id='tm-graphics-Canvas-property-setLineStyle'>        /**
</span>         * @property
         * @TODO ?
         */
        setFillStyle: function(style) {
            this.context.fillStyle = style;
            return this;
        },

        /**
         * @property
         * @TODO ?
         */
        setStrokeStyle: function(style) {
            this.context.strokeStyle = style;
            return this;
        },
        
        /**
         * @property
<span id='tm-graphics-Canvas-property-setShadow'>         * &lt;a href=&quot;http://www.w3.org/TR/2010/WD-2dcontext-20100624/#colors-and-styles&quot;&gt;http://www.w3.org/TR/2010/WD-2dcontext-20100624/#colors-and-styles&lt;/a&gt;
</span>         */
        setColorStyle: function(stroke, fill) {
            fill = fill || stroke;
            
            this.context.strokeStyle    = stroke;
            this.context.fillStyle      = fill;
            return this;
        },
        
        /**
         * @property
         * テキストをセット
         */
        setText: function(font, align, baseline) {
            var c = this.context;
            c.font          = font;
            c.textAlign     = align;
            c.textBaseline  = baseline;
        },
        
        /**
         * @property
         * ラインスタイルを一括セット
         * &lt;a href=&quot;http://www.w3.org/TR/2010/WD-2dcontext-20100624/#line-styles&quot;&gt;http://www.w3.org/TR/2010/WD-2dcontext-20100624/#line-styles&lt;/a&gt;
         */
<span id='tm-graphics-Canvas-property-width'>        setLineStyle: function(width, cap, join, miter) {
</span>            with(this.context) {
                lineWidth   = width || 1;
                lineCap     = cap   || &quot;round&quot;;
                lineJoin    = join  || &quot;round&quot;;
<span id='tm-graphics-Canvas-property-height'>                miterLimit  = miter || 10.0;
</span>            }
            return this;
        },
        
        /**
         * @property
         * 影をセット
         * - &lt;http://www.html5.jp/canvas/ref/property/shadowColor.html&gt;
<span id='tm-graphics-Canvas-property-fillStyle'>         * - &lt;http://www.w3.org/TR/2010/WD-2dcontext-20100624/#shadows&gt;
</span>         */
        setShadow: function(color, offsetX, offsetY, blur) {
            var ctx = this.context;
            
            ctx.shadowColor     = color     || &quot;black&quot;;
<span id='tm-graphics-Canvas-property-strokeStyle'>            ctx.shadowOffsetX   = offsetX   || 0;
</span>            ctx.shadowOffsetY   = offsetY   || 0;
            ctx.shadowBlur      = blur      || 0;
            
            return this;
        },
        
        getElement: function() {
            return this.element;
        },
        
    });
    
<span id='tm-graphics-Canvas-property-globalAlpha'>    tm.graphics.Canvas.MIME_TYPE_PNG = &quot;image/png&quot;;
</span>    tm.graphics.Canvas.MIME_TYPE_JPG = &quot;image/jpeg&quot;;
    tm.graphics.Canvas.MIME_TYPE_SVG = &quot;image/svg+xml&quot;;
    
    /**
     * @property    width
     * 幅
     */
    tm.graphics.Canvas.prototype.accessor(&quot;width&quot;, {
<span id='tm-graphics-Canvas-property-globalCompositeOperation'>        &quot;get&quot;: function()   { return this.canvas.width; },
</span>        &quot;set&quot;: function(v)  { this.canvas.width = v; }
    });
    
    /**
     * @property    height
     * 高さ
     */
    tm.graphics.Canvas.prototype.accessor(&quot;height&quot;, {
        &quot;get&quot;: function()   { return this.canvas.height; },
<span id='tm-graphics-Canvas-property-shadowBlur'>        &quot;set&quot;: function(v)  { this.canvas.height = v;   }
</span>    });
    
    /**
     * @property    fillStyle
     * 塗りつぶしスタイル
     */
    tm.graphics.Canvas.prototype.accessor(&quot;fillStyle&quot;, {
        &quot;get&quot;: function()   { return this.context.fillStyle; },
<span id='tm-graphics-Canvas-property-shadowColor'>        &quot;set&quot;: function(v)  { this.context.fillStyle = v;   }
</span>    });
    
    
    /**
     * @property    strokeStyle
     * ストロークスタイル
     */
    tm.graphics.Canvas.prototype.accessor(&quot;strokeStyle&quot;, {
<span id='tm-graphics-Canvas-property-shadowOffsetX'>        &quot;get&quot;: function()   { return this.context.strokeStyle; },
</span>        &quot;set&quot;: function(v)  { this.context.strokeStyle = v;   }
    });
    
    
    /**
     * @property    globalAlpha
     * アルファ指定
     */
    tm.graphics.Canvas.prototype.accessor(&quot;globalAlpha&quot;, {
<span id='tm-graphics-Canvas-property-shadowOffsetY'>        &quot;get&quot;: function()   { return this.context.globalAlpha; },
</span>        &quot;set&quot;: function(v)  { this.context.globalAlpha = v;   }
    });
    
    
    /**
     * @property    globalCompositeOperation
     * ブレンド指定
     */
    tm.graphics.Canvas.prototype.accessor(&quot;globalCompositeOperation&quot;, {
<span id='tm-graphics-Canvas-property-lineCap'>        &quot;get&quot;: function()   { return this.context.globalCompositeOperation; },
</span>        &quot;set&quot;: function(v)  { this.context.globalCompositeOperation = v;   }
    });

    /**
     * @property    shadowBlur
     * シャドウブラー
     */
<span id='tm-graphics-Canvas-property-lineJoin'>    tm.graphics.Canvas.prototype.accessor(&quot;shadowBlur&quot;, {
</span>        &quot;get&quot;: function()   { return this.context.shadowBlur; },
        &quot;set&quot;: function(v)  { this.context.shadowBlur = v;   }
    });
    

    /**
     * @property    shadowColor
     * シャドウブラーカラー
     */
<span id='tm-graphics-Canvas-property-miterLimit'>    tm.graphics.Canvas.prototype.accessor(&quot;shadowColor&quot;, {
</span>        &quot;get&quot;: function()   { return this.context.shadowColor; },
        &quot;set&quot;: function(v)  { this.context.shadowColor = v;   }
    });
    

    /**
     * @property    shadowOffsetX
<span id='tm-graphics-Canvas-property-lineWidth'>     * シャドウオフセット X 
</span>     */
    tm.graphics.Canvas.prototype.accessor(&quot;shadowOffsetX&quot;, {
        &quot;get&quot;: function()   { return this.context.shadowOffsetX; },
        &quot;set&quot;: function(v)  { this.context.shadowOffsetX = v;   }
    });
    

    /**
<span id='tm-graphics-Canvas-property-font'>     * @property    shadowOffsetY
</span>     * シャドウオフセット Y
     */
    tm.graphics.Canvas.prototype.accessor(&quot;shadowOffsetY&quot;, {
        &quot;get&quot;: function()   { return this.context.shadowOffsetY; },
<span id='tm-graphics-Canvas-property-textAlign'>        &quot;set&quot;: function(v)  { this.context.shadowOffsetY = v;   }
</span>    });
    
    /**
     * @property    lineCap
     * ライン終端の描画方法
     */
    tm.graphics.Canvas.prototype.accessor(&quot;lineCap&quot;, {
        &quot;get&quot;: function()   { return this.context.lineCap; },
<span id='tm-graphics-Canvas-property-textBaseline'>        &quot;set&quot;: function(v)  { this.context.lineCap = v;   }
</span>    });
    
    /**
     * @property    lineJoin
     * ラインつなぎ目の描画方法
     */
    tm.graphics.Canvas.prototype.accessor(&quot;lineJoin&quot;, {
        &quot;get&quot;: function()   { return this.context.lineJoin; },
<span id='tm-graphics-Canvas-property-centerX'>        &quot;set&quot;: function(v)  { this.context.lineJoin = v;   }
</span>    });
    
    /**
     * @property    miterLimit
     * マイターリミット
     */
<span id='tm-graphics-Canvas-property-centerY'>    tm.graphics.Canvas.prototype.accessor(&quot;miterLimit&quot;, {
</span>        &quot;get&quot;: function()   { return this.context.miterLimit; },
        &quot;set&quot;: function(v)  { this.context.miterLimit = v;   }
    });
    
<span id='tm-graphics-Canvas-property-imageSmoothingEnabled'>    /**
</span>     * @property    lineWidth
     * ライン幅設定
     */
    tm.graphics.Canvas.prototype.accessor(&quot;lineWidth&quot;, {
        &quot;get&quot;: function()   { return this.context.lineWidth; },
        &quot;set&quot;: function(v)  { this.context.lineWidth = v;   }
    });
    
    /**
     * @property    font
     * フォント
     */
    tm.graphics.Canvas.prototype.accessor(&quot;font&quot;, {
        &quot;get&quot;: function()   { return this.context.font; },
        &quot;set&quot;: function(v)  { this.context.font = v;   }
    });
    
    /**
     * @property    textAlign
     * テキストのアラインメント
     */
    tm.graphics.Canvas.prototype.accessor(&quot;textAlign&quot;, {
        &quot;get&quot;: function()   { return this.context.textAlign; },
        &quot;set&quot;: function(v)  { this.context.textAlign = v;   }
    });
    
    /**
     * @property    textBaseline
     * テキストのベースライン
     */
    tm.graphics.Canvas.prototype.accessor(&quot;textBaseline&quot;, {
        &quot;get&quot;: function()   { return this.context.textBaseline; },
        &quot;set&quot;: function(v)  { this.context.textBaseline = v;   }
    });
    
    /**
     * @property    centerX
     * センターX
     */
    tm.graphics.Canvas.prototype.getter(&quot;centerX&quot;, function() {
        return this.canvas.width/2;
    });
    
    /**
     * @property    centerY
     * センターY
     */
    tm.graphics.Canvas.prototype.getter(&quot;centerY&quot;, function(){
        return this.canvas.height/2;
    });

    /**
     * @property    imageSmoothingEnabled
     * 画像スムージング設定
     */
    tm.graphics.Canvas.prototype.accessor(&quot;imageSmoothingEnabled&quot;, {
        &quot;get&quot;: function() {
            return this.context.imageSmoothingEnabled;
        },
        &quot;set&quot;: function(v) {
            this.context.imageSmoothingEnabled = v;
            this.context.webkitImageSmoothingEnabled = v;
            this.context.mozImageSmoothingEnabled = v;
        }
    });
    
})();

















</pre>
</body>
</html>
